import cv2
import numpy as np
from ultralytics import YOLO
import os
import random
import yaml
from pathlib import Path

# --- CONFIGURATION ---
STAGE1_MODEL_PATH = 'traffic_project/stage1_detector/weights/best.pt'
STAGE2_MODEL_PATH = 'traffic_classifier.keras'  # Pointing to the new model
CLASS_NAMES_PATH = 'class_names.txt'          # The file generated by step 04
CONFIDENCE_THRESHOLD = 0.4                    # Min confidence to detect a box
USE_DUMMY_CLASSIFIER = False                  # Set to False to use the real brain

# Load Keras only if needed (saves startup time if just testing Stage 1)
if not USE_DUMMY_CLASSIFIER:
    import tensorflow as tf

class TwoStageDetector:
    def __init__(self):
        # 1. Load Stage 1 (Detector)
        if not os.path.exists(STAGE1_MODEL_PATH):
            raise FileNotFoundError(f"[ERROR] Stage 1 model not found at {STAGE1_MODEL_PATH}. Run 02_train_detector.py first.")
        
        print(f"[INFO] Loading Stage 1 Detector from {STAGE1_MODEL_PATH}...")
        self.detector = YOLO(STAGE1_MODEL_PATH)
        
        # 2. Load Stage 2 (Classifier)
        if not USE_DUMMY_CLASSIFIER:
            if not os.path.exists(STAGE2_MODEL_PATH):
                raise FileNotFoundError(f"[ERROR] Stage 2 model not found at {STAGE2_MODEL_PATH}. Run 04_train_classifier.py first.")
            
            if not os.path.exists(CLASS_NAMES_PATH):
                raise FileNotFoundError(f"[ERROR] Class names file not found at {CLASS_NAMES_PATH}. Run 04_train_classifier.py first.")

            print(f"[INFO] Loading Stage 2 Classifier from {STAGE2_MODEL_PATH}...")
            self.classifier = tf.keras.models.load_model(STAGE2_MODEL_PATH)
            
            # Load class names from the text file
            with open(CLASS_NAMES_PATH, "r") as f:
                self.classes = [line.strip() for line in f.readlines()]
            print(f"[INFO] Loaded {len(self.classes)} classes: {self.classes[:5]}...")
        else:
            print("[WARN] Using Dummy Classifier (Placeholders)")
            self.classes = ["Dummy_Sign"]

    def classify_crop(self, crop):
        """
        Takes a BGR crop (from cv2), preprocesses it for ResNet, and returns label/conf.
        """
        if USE_DUMMY_CLASSIFIER:
            return "Sign", 0.99
        
        # 1. Preprocess
        # Resize to 224x224 (Model input size)
        img_resized = cv2.resize(crop, (224, 224))
        
        # Convert BGR (OpenCV) to RGB (What TensorFlow/Keras expects)
        img_rgb = cv2.cvtColor(img_resized, cv2.COLOR_BGR2RGB)
        
        # Add batch dimension (1, 224, 224, 3)
        img_batch = np.expand_dims(img_rgb, axis=0)
        
        # Note: The Rescaling layer is inside the model, so we don't need to divide by 255 here
        
        # 2. Predict
        preds = self.classifier.predict(img_batch, verbose=0)
        idx = np.argmax(preds)
        confidence = float(np.max(preds))
        
        return self.classes[idx], confidence

    def process_image(self, image_path):
        img = cv2.imread(image_path)
        if img is None:
            print(f"[ERROR] Could not load image: {image_path}")
            return

        print(f"[INFO] Processing: {image_path}")
        
        # 1. Detection Pass (Stage 1)
        results = self.detector(img, conf=CONFIDENCE_THRESHOLD, verbose=False)
        h_img, w_img = img.shape[:2]
        
        detections_found = False

        for result in results:
            boxes = result.boxes
            for box in boxes:
                detections_found = True
                
                # Get coordinates
                x1, y1, x2, y2 = map(int, box.xyxy[0])
                
                # 2. Context Padding
                # Expand the box slightly so we don't cut the sign's edge
                pad_x = int((x2 - x1) * 0.1)
                pad_y = int((y2 - y1) * 0.1)
                
                crop_x1 = max(0, x1 - pad_x)
                crop_y1 = max(0, y1 - pad_y)
                crop_x2 = min(w_img, x2 + pad_x)
                crop_y2 = min(h_img, y2 + pad_y)
                
                # 3. Crop & Sanity Check
                sign_crop = img[crop_y1:crop_y2, crop_x1:crop_x2]
                if sign_crop.size == 0: continue

                # 4. Classification Pass (Stage 2)
                label, conf = self.classify_crop(sign_crop)
                
                print(f"   > Found: {label} ({conf:.2f}) at [{x1}, {y1}]")

                # 5. Draw Visuals
                # Box
                color = (0, 255, 0) # Green
                cv2.rectangle(img, (x1, y1), (x2, y2), color, 2)
                
                # Label Background & Text
                label_text = f"{label} {conf:.2f}"
                (text_w, text_h), baseline = cv2.getTextSize(label_text, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 1)
                
                cv2.rectangle(img, (x1, y1 - text_h - 10), (x1 + text_w, y1), color, -1)
                cv2.putText(img, label_text, (x1, y1 - 5),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)

        if not detections_found:
            print("[INFO] No signs detected.")
        else:
            # Show Output Window
            cv2.imshow("Two-Stage Traffic Sign Detector", img)
            print("[INFO] Press any key to close the window...")
            cv2.waitKey(0)
            cv2.destroyAllWindows()

if __name__ == "__main__":
    # AUTO-TEST LOGIC
    # It tries to find a valid image to test on automatically
    
    # 1. Try to find an image in the validation folder from Step 1
    if os.path.exists('traffic_signs.yaml'):
        with open('traffic_signs.yaml') as f:
            data = yaml.safe_load(f)
            base = Path(data['path'])
            val_rel = Path(data['val'])
            full_val_path = base / val_rel
            
            if full_val_path.exists():
                # Get all jpg images
                test_images = list(full_val_path.glob("*/*.jpg")) + list(full_val_path.glob("*.jpg"))
                if test_images:
                    # Pick a random one
                    target_image = str(random.choice(test_images))
                    
                    # Initialize & Run
                    try:
                        pipeline = TwoStageDetector()
                        pipeline.process_image(target_image)
                    except Exception as e:
                        print(f"\n[CRITICAL ERROR] {e}")
                else:
                    print(f"[WARN] No JPG images found in {full_val_path}")
            else:
                print(f"[ERROR] Validation path does not exist: {full_val_path}")
    else:
        print("[ERROR] 'traffic_signs.yaml' not found. Cannot auto-detect test images.")
        print("Please run this script passing a manual image path if you have one.")